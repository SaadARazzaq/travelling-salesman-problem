"""
ABSTRACT:

This is a Python implementation of the Hill Climbing algorithm for the Traveling Salesman Problem (TSP).

The TSP is a classic problem in computer science and operations research, where the goal is to find the shortest possible route that visits every city exactly once and returns to the starting city. It is a well-known NP-hard problem, which means that there is no known algorithm that can solve it efficiently for large problem sizes.

The Hill Climbing algorithm is a local search algorithm that starts with a random solution and iteratively improves it by considering its neighboring solutions. In this implementation, the neighboring solutions are generated by swapping two cities in the current solution. The algorithm terminates when no better neighboring solution is found.

The main functions in this implementation are:

1. random_solution(tsp): generates a random solution to the TSP by randomly shuffling the cities.

2. route_length(tsp, solution): computes the total length of a given TSP solution by summing the distances between consecutive cities.

3. get_neighbours(solution): generates a list of neighboring solutions to a given TSP solution by swapping two cities.

4. get_best_neighbour(tsp, neighbours_solution): finds the best neighboring solution to a given TSP solution by computing their lengths and returning the shortest one.

5. hill_climbing_algorithm(tsp): implements the Hill Climbing algorithm for the TSP by repeatedly generating neighboring solutions and selecting the best one until no improvement is possible.

The main() function sets up a sample TSP problem and runs the Hill Climbing algorithm on it. The distances between the cities are defined by the tsp list of lists. The output of the algorithm is the best solution found and its length, as well as a list of all the neighboring solutions explored during the search.
"""

import random
from random import *
import colorama

def random_solution(tsp):  # Generates random solution
    """
    You can also use random.shuffle(cities) to shuffle all the values of cities
    """
    solution = []  # This will store the solution
    cities = list(range(len(tsp)))  # This makes a list of all the cities that we have i.e. [0, 1, 2, 3]
    for i in range(0, len(tsp)):
        random_city = cities[randint(0, len(cities)-1)]  # Stores a random city inside the variable random_city
        solution.append(random_city)
        cities.remove(random_city)  # Removes that city from cities so that it won't get repeated
    return solution

def route_length(tsp, solution):
    routelength = 0
    for i in range(0, len(solution)):
        routelength += tsp[solution[i-1]][solution[i]]  # This will calculate and add the route lengths of each path and will work like e.g. tsp[city1][city2] and add the distance of these two cities in routelength
    return routelength

def get_neighbours(solution):
    neighbours = []
    n = len(solution)
    for i in range(n):
        for j in range(i+1, n):
            neighbour = solution.copy()  # Makes a copy of solution and store it in new list
            neighbour[i], neighbour[j] = neighbour[j], neighbour[i]  # Swaps the new lists adjacents. I have used bubble sort algorithm here
            neighbours.append(neighbour)  # Appends that new list into another list so that our swapping gets saved and we get the neighbours
    return neighbours

def get_best_neighbour(tsp, neighbours_solution):
    best_neighbour_route_length = route_length(tsp, neighbours_solution[0])
    best_neighbour = neighbours_solution[0]  # Initially we assign the zero'th index neighbour as the best neighbour
    for i in neighbours_solution:
        current_route_length = route_length(tsp, i)
        if current_route_length < best_neighbour_route_length:
            best_neighbour_route_length = current_route_length
            best_neighbour = i
    return best_neighbour, best_neighbour_route_length

def hill_climbing_algorithm(tsp):
    current_solution = random_solution(tsp)  # Step 1: (a) Assign Random Solution to Current Solution
    current_route_length = route_length(tsp, current_solution)  # Step 1: (b) Assign route length to Current Route Length. Route length will have problem space and the solution
    neighbours_solution = get_neighbours(current_solution)
    best_neighbour, best_neighbour_route_length = get_best_neighbour(tsp, neighbours_solution)

    while best_neighbour_route_length < current_route_length:  # Compare that if current route length is greater, then assign best_neighbour_route_length to current_route_length. This while loop is for double check. The loop will end when we no longer find out the best route length than the current route length.
        current_solution = best_neighbour
        current_route_length = best_neighbour_route_length
        neighbours_solution = get_neighbours(current_solution)
        best_neighbour, best_neighbour_route_length = get_best_neighbour(tsp, neighbours_solution)
    return current_solution, current_route_length


def main():
    tsp = [ # This list of lists for problem space. This is the space on which algorithm will apply and find the goal state. These are also the distance between the cities.
        [0, 400, 500, 300],  # From city 0, it is distance to other cites
        [400, 0, 300, 500],  # From city 1, it is distance to other cites
        [500, 300, 0, 400],  # From city 2, it is distance to other cites
        [300, 500, 400, 0]   # From city 3, it is distance to other cites
    ]

    print(end=colorama.Fore.YELLOW)
    print("TSP grid:")
    for i in tsp:
        print(i)

    print(colorama.Fore.GREEN + "\n\nPerforming hill climbing algorithm...\n" + colorama.Fore.RESET)
    solution, route_length = hill_climbing_algorithm(tsp)

    print(colorama.Fore.CYAN + "\n -> Successors: ",get_neighbours(solution))
    print(colorama.Fore.GREEN + f"\n -> Best solution found: {solution}")
    print("\n -> Route length of best solution:", route_length)
    print(end=colorama.Fore.RESET)
    print("\n")



if __name__ == "__main__":
    main()
